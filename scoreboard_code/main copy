/*
 * main.cpp
 *
 * main file for the scoreboard module
 */

#include <avr/interrupt.h>
#include <avr/io.h>

const uint8_t CMD_INDEX = 1;
const uint8_t UPPER_INDEX = 2;
const uint8_t MID_INDEX = 3;
const uint8_t LOWER_INDEX = 4;

const uint8_t MESSAGE_LENGTH = 6;
uint8_t rx_buffer[MESSAGE_LENGTH];
volatile uint8_t rx_buffer_index = 0;

volatile uint8_t upper_score_byte = 0;
volatile uint8_t middle_score_byte = 0;
volatile uint8_t lower_score_byte = 0;
volatile uint32_t score = 0;

void configure( void );
void concatentateScore( void );
void awaitMessage( void );
uint8_t receiveByte( void );

int main( void ) {

    configure();
    sei();
    // DDRD |= ( 1 << PORTD2 );
    // DDRC = 0x3F;

    // // Force one digit & pattern
    // PORTC = 0x3F;
    // PORTD |= ( 1 << PORTD2 );

    while ( 1 ) {
        awaitMessage();
        concatentateScore();
    }
}

void configure() {

    //***********************************************
    // Configure USART
    //***********************************************
    UCSR0A = ( 0 << U2X0 ) | ( 0 << MPCM0 );
    UCSR0B = ( 0 << RXCIE0 ) | ( 1 << RXEN0 ) | ( 0 << TXEN0 ) | ( 1 << UCSZ02 ); //disable receiver interrupt, Enable receiver, set UCSZ02 for 9-bit format

    UCSR0C = ( 1 << UCSZ01 ) | ( 1 << UCSZ00 ); // Configure 9-bit format
    UBRR0 = 4;                                  //Set baud rate at 250k
    PORTD &= ~( 1 << PORTD6 );                  //Set PD6 low to enable RS485 receiver
    sei();

    //Configure Pins
    //DDRB = (1<<PORTB0)|(1<<PORTB1)|(1<<PORTB2);
    DDRC = ( 1 << PORTC5 ) | ( 1 << PORTC4 ) | ( 1 << PORTC3 ) | ( 1 << PORTC2 ) | ( 1 << PORTC1 ) |
           ( 1 << PORTC0 );
    DDRD = ( 1 << PORTD2 ) | ( 1 << PORTD3 ) | ( 1 << PORTD4 ) | ( 1 << PORTD6 ) | ( 1 << PORTD7 );
    //*****************************************************************************
    //Configure Timer 1
    //*****************************************************************************
    //Run in CTC (Clear Timer on Compare)
    TCCR1A = ( 0 << COM1A1 ) | ( 0 << COM1A0 ) | ( 0 << WGM11 ) | ( 0 << WGM10 );
    //CTC Mode, CLK/256
    TCCR1B = ( 0 << WGM13 ) | ( 1 << WGM12 ) | ( 1 << CS12 ) | ( 0 << CS11 ) | ( 0 << CS10 );
    TIMSK1 = ( 1 << OCIE1A );
    OCR1A = 62; // (1s)*(16 Mhz/256)
    //*********************************************************************************
}

void concatentateScore() {
    score = ((uint32_t)upper_score_byte  << 16) |
            ((uint32_t)middle_score_byte << 8)  |
            (uint32_t)lower_score_byte;
}

uint8_t receiveByte() {
    while ( !( UCSR0A & ( 1 << RXC0 ) ) )
        ;
    return UDR0;
}

void awaitMessage() {
    rx_buffer_index = 0;
    receiveByte(); // Start Byte
    receiveByte(); // Command
    upper_score_byte = receiveByte(); // Upper byte
    middle_score_byte = receiveByte(); // middle byte
    lower_score_byte = receiveByte(); // lower byte
    receiveByte(); // end byte

}

ISR( TIMER1_COMPA_vect ) {
    static uint8_t digit_index = 0; //Index for tracking digit activation
    static uint8_t display_value = 0;
    static uint16_t count_index = 0;
    static uint8_t debounced_state = 0;
    static uint16_t accumulate = 0;

    //Turn on digit
    PORTD = ( PORTD & 0b11100011 ) | ( digit_index << 2 );
    //PORTD = 0b11100011|(digit_index<<2);

    //Calculate the digit value
    switch ( digit_index ) {
    case 4:
        display_value = score % 10;
        break; //Ones
    case 3:
        display_value = ( score / 10 ) % 10;
        break; //Tens
    case 2:
        display_value = ( score / 100 ) % 10;
        break; //Hundreds
    case 1:
        display_value = ( score / 1000 ) % 10;
        break; //Thousands
    case 0:
        display_value = ( score / 10000 ) % 10;
        break; //Ten Thousands
    }

    //Decode segment values
    switch ( display_value ) {
    case 0:
        PORTD = ( PORTD & 0x7F ) | 0x00;
        PORTC = ( PORTC & 0xC0 ) | 0x3F;
        break;
    case 1:
        PORTD = ( PORTD & 0x7F ) | 0x00;
        PORTC = ( PORTC & 0xC0 ) | 0x06;
        break;
    case 2:
        PORTD = ( PORTD & 0x7F ) | 0x80;
        PORTC = ( PORTC & 0xC0 ) | 0x1B;
        break;
    case 3:
        PORTD = ( PORTD & 0x7F ) | 0x80;
        PORTC = ( PORTC & 0xC0 ) | 0x0F;
        break;
    case 4:
        PORTD = ( PORTD & 0x7F ) | 0x80;
        PORTC = ( PORTC & 0xC0 ) | 0x26;
        break;
    case 5:
        PORTD = ( PORTD & 0x7F ) | 0x80;
        PORTC = ( PORTC & 0xC0 ) | 0x2D;
        break;
    case 6:
        PORTD = ( PORTD & 0x7F ) | 0x80;
        PORTC = ( PORTC & 0xC0 ) | 0x3D;
        break;
    case 7:
        PORTD = ( PORTD & 0x7F ) | 0x00;
        PORTC = ( PORTC & 0xC0 ) | 0x07;
        break;
    case 8:
        PORTD = ( PORTD & 0x7F ) | 0x80;

        PORTC = ( PORTC & 0xC0 ) | 0x3F;
        break;
    case 9:
        PORTD = ( PORTD & 0x7F ) | 0x80;
        PORTC = ( PORTC & 0xC0 ) | 0x27;
        break;
    default:
        PORTD = ( PORTD & 0x7F );
        PORTC = ( PORTC & 0xC0 ) | 0x3F;
        break;
    }

    if ( digit_index++ > 3 ) {
        digit_index = 0;
    }

}